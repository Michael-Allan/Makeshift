#!/usr/bin/env --split-string=${JDK_HOME}/bin/java @building/javac_arguments @building/java_arguments \c [SS]
package building; // [AFN]

// Usage from working directory `<PROJECTS>/`:  build <PROJECT>/ <target>…

import java.io.IOException;
import java.net.*;
import java.nio.file.*;

import static java.lang.ProcessBuilder.Redirect.INHERIT;
import static java.nio.file.Files.getLastModifiedTime;


/** A shell command to compile the code of a given project and prepare it for use.
  */
final class BuildCommand { // [AFN]



    private BuildCommand() {}



    /** Execute the command as given by the shell.
      */
    public static void main( final String[] arguments ) throws BootstrappingFailure {
        if( arguments.length < 2 ){
            System.err.println( "Usage: build <PROJECT>/ <target>..." );
            return; }

        new BuildCommand().execute(); }



////  P r i v a t e  ////////////////////////////////////////////////////////////////////////////////////


    /** Execute the command.
      */
    private void execute() throws BootstrappingFailure {
        // Already the working directory is `*PROJECTS*/`.  `../build_instructions.brec`
        final Path sourceFile = Path.of( "building", "BuilderBuilder.java" );
        final Path outputDirectory = Path.of( System.getProperty("java.io.tmpdir"), "building" );
        final Path classFile = outputDirectory.resolve( Path.of( "building", "BuilderBuilder.class" ));
        final boolean toCompile;
        final boolean wasClean;
        if( Files.exists( classFile )) {
            try { toCompile =
              getLastModifiedTime(sourceFile).compareTo(getLastModifiedTime(classFile)) >= 0; }
            catch( IOException x ) { throw new BootstrappingFailure( x ); }
            wasClean = false; }
        else {
            toCompile = true;
            wasClean = !Files.isDirectory( outputDirectory ); }
        if( toCompile ) {

          // Compile the builder-builder code
          // ────────────────────────────────
            final ProcessBuilder pB = new ProcessBuilder(
              System.getProperty("java.home") + "/bin/javac", /* The Java installation
                  at `java.home` is known to include `javac` because also it is a JDK
                  installation, as assured by the `JDK_HOME` at top. */
                "@building/javac_arguments", "@building/javac_arguments_addendum",
                "building/BuilderBuilder.java" );
            pB.redirectOutput( INHERIT );
            pB.redirectError( INHERIT );
            try {
                final int exitValue =  pB.start().waitFor();
                if( exitValue == 1 ) { System.err.println( "build: Stopped on `javac` error" ); }
                  // Already `javac` has told the details.
                else if( exitValue != 0 ) { throw new BootstrappingFailure( "Exit value of "
                  + exitValue + " from process: " + pB.command() ); }}
            catch( InterruptedException|IOException x ) { throw new BootstrappingFailure( x ); }}
        try {

          // Load the builder-builder code
          // ─────────────────────────────
            final Class<?> cA;
            if( wasClean ) { /* Then the single directory given by `../javac_arguments` for the
                  `--class-path` of the present runtime (namely the output directory `/tmp/building/`)
                  did not exist before the present runtime.  It exists now, but still the class loader
                  will not look there for its class files (JDK 14.0.2). */
                final ClassLoader cL; // Therefore make a new class loader.
                try { cL = new URLClassLoader(
                  new URL[] { new URL( "file://" + outputDirectory + "/" )}); }
                catch( MalformedURLException x ) { throw new BootstrappingFailure( x ); }
                cA = cL.loadClass( "building.BuilderBuilder" ); }
            else cA = Class.forName( "building.BuilderBuilder" );

          // Make a builder builder
          // ──────────────────────
            final Object builderBuilder = cA.getDeclaredConstructor().newInstance(); }
        catch( ReflectiveOperationException x ) { throw new BootstrappingFailure( x ); }}



   // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


    private final class BootstrappingFailure extends Exception {

        private BootstrappingFailure( Exception cause ) { super( cause ); }

        private BootstrappingFailure( String message ) { super( message ); }}}



// NOTES
// ─────
//   AFN  Atypical file naming is allowed here.  ‘The compiler does not enforce the optional restriction
//        defined at the end of JLS §7.6, that a type in a named package should exist in a file whose
//        name is composed from the type name followed by the .java extension.’
//        http://openjdk.java.net/jeps/330
//        https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-7.6
//
//   SS · Here the long form `--split-string` (as opposed to `-S`) enables Emacs to recognize this file
//        as Java source code.  See the note apropos ‘source-launch files encoded with a shebang’ at
//        `http://reluk.ca/project/Java/Emacs/jmt-mode.el`.



                                                        // Copyright © 2020  Michael Allan.  Licence MIT.
