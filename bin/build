#!/usr/bin/env --split-string=${JDK_HOME}/bin/java @building/Makeshift/java_arguments @building/Makeshift/java_arguments_addendum @building/Makeshift/java_javac_arguments \c [SS]
package building.Makeshift; // [AFN]

// Usage:  build <PROJECT-PROPER-PATH> <target>…
//
// Changes to this file immediately affect the next runtime.  Treat it as a script.

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;

import static java.io.File.separatorChar;
import static java.lang.ProcessBuilder.Redirect.INHERIT;
import static java.nio.file.Files.getLastModifiedTime;


/** A shell command to compile the code of a given project and prepare it for use.
  */
final class BuildCommand { // [AFN]


    private BuildCommand( final Path projectPath, final String[] arguments ) {
        this.projectPath = projectPath;
        this.arguments = arguments; }



    /** Takes a `build` command from the shell.
      */
    public static void main( final String[] arguments ) {
        if( arguments.length < 2 ){
            System.err.println( "Usage: build <PROJECT-PROPER-PATH> <target>..." );
            System.exit( 1 ); }
        final String argument = arguments[0];
        final Path projectPath = Path.of( argument ); /* Effectively filters out input variance.
          Whether or not the argument ends with ‘/’ has no effect on `projectPath`. */
        if( projectPath.isAbsolute() ) {
            System.err.println( "build: Not a relative path: " + argument );
            System.exit( 1 ); }
        new BuildCommand(projectPath,arguments).execute(); }



////  P r i v a t e  ////////////////////////////////////////////////////////////////////////////////////


    private final String[] arguments;



    /** Executes the command.
      */
    private void execute() { // A bootstrapped process comprising three build stages:

      // 1. Build the builder builder
      // ────────────────────────────
        final List<String> compilerArguments = new ArrayList<>(); // Empty if no code needs compiling.
        final Path outDirectory;
        final boolean wasClean; {
            // Already the working directory is the command directory.  `../build_instructions.brec`
            final Path p = pathOf( "building.Makeshift" ); // Proper path of the present project.
            outDirectory = Path.of(System.getProperty("java.io.tmpdir")).resolve( p );
            wasClean = !Files.isDirectory( outDirectory );
            for( String s: new String[]{ "BuilderBuilder", /*dependencies*/"Bootstrap", "Builder" }) {
                final Path sourceFile = p.resolve( s + ".java" );
                final Path classFile = outDirectory.resolve( p.resolve( s + ".class" ));
                final boolean toCompile;
                if( Files.exists( classFile )) {
                    try { toCompile =
                      getLastModifiedTime(sourceFile).compareTo(getLastModifiedTime(classFile)) >= 0; }
                    catch( IOException x ) { throw new Failure( x ); }}
                else toCompile = true;
                if( toCompile ) compilerArguments.add( sourceFile.toString() ); }}
        final int sourceCount = compilerArguments.size();
        if( sourceCount > 0 ) {

          // compile the code
          // ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            // Changing?  Sync → `Bootstrap.compile`.
            int a = 0;
            compilerArguments.add( a++, System.getProperty("java.home") + "/bin/javac" );
              // The Java installation at `java.home` is known to include `javac` because also
              // it is a JDK installation, as assured by the `JDK_HOME` at top.
            compilerArguments.add( a++, "@building/Makeshift/java_javac_arguments" );
            compilerArguments.add( a,   "@building/Makeshift/javac_arguments" );
            final ProcessBuilder pB = new ProcessBuilder( compilerArguments );
            pB.redirectOutput( INHERIT );
            pB.redirectError( INHERIT );
            try {
                final int exitValue =  pB.start().waitFor();
                if( exitValue == 1 ) {
                    System.err.println( "build: Stopped on `javac` error" );
                    System.exit( 1 ); } // Already `javac` has told the details.
                else if( exitValue != 0 ) throw new Failure( "Exit value of " + exitValue
                  + " from process: " + pB.command() ); }
            catch( InterruptedException|IOException x ) { throw new Failure( x ); }}
        if( wasClean ) {

          // prepare to load the code
          // ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
          // The directory given in `../java_javac_arguments` for the class path (the output directory)
          // did not exist before the present runtime.  It exists now, but still the class loader will
          // not look there for class files (JDK 14.0.2).  Therefore make a new class loader.
            try {
              loader = new URLClassLoader( new URL[] { new URL( "file://" + outDirectory + "/" )}); }
            catch( MalformedURLException x ) { throw new Failure( x ); }}
        try {
            Class<?> c;
            if( sourceCount > 0 ) {

              // inform the user
              // ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
                c = load( "building.Makeshift.Bootstrap" );
                final Object bootstrap = c.getField("i").get( null/*static*/ );
                c.getMethod( "printProgressLeader", String.class, String.class )
                  .invoke( bootstrap, null/*bootstrapping*/, "javac" );
                System.out.println( sourceCount ); }

          // get a builder builder for the project to be built
          // ┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈
            c = load( "building.Makeshift.BuilderBuilder" );
            final Object builderBuilder = c.getMethod( "forPath", Path.class )
              .invoke( null/*static*/, projectPath );
            c = builderBuilder.getClass();

          // 2. Build the builder
          // ────────────────────
            c.getMethod("build").invoke( builderBuilder );
            final Object builder = c.getMethod("newBuilder").invoke( builderBuilder );
            c = builder.getClass();

          // 3. Build the requested targets
          // ──────────────────────────────
            final int tN = arguments.length;
            int t = 1;
            do c.getMethod("build",String.class).invoke( builder, arguments[t] );
            while( ++t < tN ); }
        catch( final InvocationTargetException xIT ) {
            final Throwable x = xIT.getCause();
            if( x != null && "building.Makeshift.Builder$UserError".equals( x.getClass().getName() )) {
                System.err.println( "build: " + x.getMessage() );
                System.exit( 1 ); }
            else throw new Failure( xIT ); }
        catch( ReflectiveOperationException x ) { throw new Failure( x ); }}



    private Class<?> load( final String className ) throws ClassNotFoundException {
        return loader == null? Class.forName(className): loader.loadClass(className); }



    private ClassLoader loader; // Null unless a special one is required.



    /** Converts `JavaPackage` to an equivalent relative path.
      */
    public static Path pathOf( final String JavaPackage ) {
        return Path.of( pathStringOf( JavaPackage )); }
        // Changing?  Sync → `Bootstrap.pathOf`.



    /** Converts `JavaPackage` to an equivalent relative path.
      */
    public static String pathStringOf( final String JavaPackage ) {
        return JavaPackage.replace( '.', separatorChar ); }
        // Changing?  Sync → `Bootstrap.pathStringOf`.



    /** The proper path of the project to build.
      */
    private final Path projectPath;



   // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━


    private static final class Failure extends RuntimeException {

        private Failure( Exception cause ) { super( cause ); }

        private Failure( String message ) { super( message ); }}}



// NOTES
// ─────
//   AFN  Atypical file naming is allowed here.  ‘The compiler does not enforce the optional restriction
//        defined at the end of JLS §7.6, that a type in a named package should exist in a file whose
//        name is composed from the type name followed by the .java extension.’
//        http://openjdk.java.net/jeps/330
//        https://docs.oracle.com/javase/specs/jls/se15/html/jls-7.html#jls-7.6
//
//   SS · Here the long form `--split-string` (as opposed to `-S`) enables Emacs to recognize this file
//        as Java source code.  See the note apropos ‘source-launch files encoded with a shebang’ at
//        `http://reluk.ca/project/Java/Emacs/jmt-mode.el`.



                                                        // Copyright © 2020  Michael Allan.  Licence MIT.
